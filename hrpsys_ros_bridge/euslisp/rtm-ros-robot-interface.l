(require :robot-interface "package://pr2eus/robot-interface.l")

(ros::load-ros-manifest "dynamic_reconfigure")
(ros::roseus-add-msgs "hrpsys_ros_bridge")
(ros::load-ros-manifest "hrpsys_ros_bridge")

(defclass rtm-ros-robot-interface
  :super robot-interface
  :slots ()
  )

(defmethod rtm-ros-robot-interface
  (:init
   (&rest args)
   (prog1
       (send-super* :init args)
     (send self :define-all-ROSBridge-srv-methods)
     (ros::subscribe "/motor_states" hrpsys_ros_bridge::MotorStates
                     #'send self :rtmros-motor-states-callback :groupname groupname)
     (mapcar #'(lambda (x)
                 (ros::subscribe (format nil "/~A" (string-downcase x)) geometry_msgs::WrenchStamped
                                 #'send self :rtmros-force-sensor-callback x :groupname groupname)
                 (ros::subscribe (format nil "/off_~A" (string-downcase x)) geometry_msgs::WrenchStamped
                                 #'send self :rtmros-force-sensor-callback (read-from-string (format nil ":off-~A" (string-downcase x))) :groupname groupname)
                 (ros::subscribe (format nil "/ref_~A" (string-downcase x)) geometry_msgs::WrenchStamped
                                 #'send self :rtmros-force-sensor-callback (read-from-string (format nil ":reference-~A" (string-downcase x))) :groupname groupname))
             (send-all (send robot :force-sensors) :name))
     (ros::subscribe "/zmp" geometry_msgs::PointStamped
                     #'send self :rtmros-zmp-callback :groupname groupname)
     (ros::subscribe "/imu" sensor_msgs::Imu
                     #'send self :rtmros-imu-callback :groupname groupname)
     ))
  (:rtmros-motor-states-callback
   (msg)
   (send self :set-robot-state1 :motor-extra-data (send msg :extra_data))
   (send self :set-robot-state1 :temperature (send msg :temperature)))
  (:rtmros-zmp-callback
   (msg)
   (let ((p (send msg :point)))
     (send self :set-robot-state1 :zmp (float-vector (send p :x) (send p :y) (send p :z)))))
  (:rtmros-imu-callback
   (msg)
   (send self :set-robot-state1 :imu msg)
   (let ((imucoords (make-coords :rot (ros::tf-quaternion->rot (send (cdr (assoc :imu robot-state)) :orientation)))))
     (send robot :move-coords imucoords (car (send robot :imu-sensors)))))
  (:rtmros-force-sensor-callback
   (fsensor-name msg)
   (let ((wrc (send msg :wrench)))
     (send self :set-robot-state1 fsensor-name
           (float-vector (send (send wrc :force) :x)
                         (send (send wrc :force) :y)
                         (send (send wrc :force) :z)
                         (send (send wrc :torque) :x)
                         (send (send wrc :torque) :y)
                         (send (send wrc :torque) :z)))))
  (:tmp-force-moment-vector-for-limb
   (f/m fsensor-name &optional (topic-name-prefix nil)) ;; topic-name-prefix is "off" or "reference"
   (let ((key-name (if topic-name-prefix
                       (read-from-string (format nil ":~A-~A" topic-name-prefix (string-downcase fsensor-name)))
                     fsensor-name)))
     (subseq (cdr (assoc key-name robot-state))
             (if (eq f/m :force) 0 3)
             (if (eq f/m :force) 3 6))))
  (:tmp-force-moment-vector
   (f/m &optional (limb) (topic-name-prefix nil)) ;; topic-name-prefix is "off" or "reference"
   (if limb
       (send self :tmp-force-moment-vector-for-limb f/m (send (car (send robot limb :force-sensors)) :name) topic-name-prefix)
     (mapcar #'(lambda (x)
                 (send self :tmp-force-moment-vector-for-limb f/m x topic-name-prefix))
             (send-all (send robot :force-sensors) :name))))
  (:force-vector
   (&optional (limb))
   "Returns :force-vector [N] list for all limbs obtained by :state.
    If a limb argument is specified, returns a vector for the limb."
   (send self :tmp-force-moment-vector :force limb))
  (:moment-vector
   (&optional (limb))
   "Returns :moment-vector [Nm] list for all limbs obtained by :state.
    If a limb argument is specified, returns a vector for the limb."
   (send self :tmp-force-moment-vector :moment limb))
  (:off-force-vector
   (&optional (limb))
   "Returns offset-removed :force-vector [N] list for all limbs obtained by :state.
    This value corresponds to RemoveForceSensorLinkOffset RTC.
    If a limb argument is specified, returns a vector for the limb."
   (send self :tmp-force-moment-vector :force limb "off"))
  (:off-moment-vector
   (&optional (limb))
   "Returns offset-removed :moment-vector [Nm] list for all limbs obtained by :state.
    This value corresponds to RemoveForceSensorLinkOffset RTC.
    If a limb argument is specified, returns a vector for the limb."
   (send self :tmp-force-moment-vector :moment limb "off"))
  (:reference-force-vector
   (&optional (limb))
   "Returns reference force-vector [N] list for all limbs obtained by :state.
    This value corresponds to StateHolder and SequencePlayer RTC.
    If a limb argument is specified, returns a vector for the limb."
   (send self :tmp-force-moment-vector :force limb "reference"))
  (:reference-moment-vector
   (&optional (limb))
   "Returns reference moment-vector [Nm] list for all limbs obtained by :state.
    This value corresponds to StateHolder and SequencePlayer RTC.
    If a limb argument is specified, returns a vector for the limb."
   (send self :tmp-force-moment-vector :moment limb "reference"))
  (:absolute-force-vector
   (&optional (limb))
   "Returns offset-removed :force-vector [N] list for all limbs in world frame obtained by :state.
    This value corresponds to RemoveForceSensorLinkOffset RTC.
    If a limb argument is specified, returns a vector for the limb."
   (if limb
       (send (car (send robot limb :force-sensors)) :rotate-vector (send self :off-force-vector limb))
     (mapcar #'(lambda (fs force)
                 (send fs :rotate-vector force))
             (send robot :force-sensors) (send self :off-force-vector))))
  (:absolute-moment-vector
   (&optional (limb))
   "Returns offset-removed :moment-vector [Nm] list for all limbs in world frame obtained by :state.
    This value corresponds to RemoveForceSensorLinkOffset RTC.
    If a limb argument is specified, returns a vector for the limb."
   (if limb
       (send (car (send robot limb :force-sensors)) :rotate-vector (send self :off-moment-vector limb))
     (mapcar #'(lambda (fs moment)
                 (send fs :rotate-vector moment))
             (send robot :force-sensors) (send self :off-moment-vector))))
  (:zmp-vector
   (&optional (wrt :local))
   "Returns zmp vector [mm].
    If wrt is :local, returns zmp in the base-link frame. If wrt is :world, returns zmp in the world frame."
   (let ((zmp (scale 1e3 (cdr (assoc :zmp robot-state))))) ;; [m] -> [mm]
     (case wrt
       (:local zmp)
       (:world (send (car (send robot :links)) :transform-vector zmp)))))
  (:temperature-vector
   ()
   "Returns temperature vector."
   (cdr (assoc :temperature robot-state)))
  (:motor-extra-data
   ()
   "Returns motor extra data. Please see iob definition for each system."
   (let* ((d (cdr (assoc :motor-extra-data robot-state)))
          (dims (mapcar #'(lambda (x) (send x :size)) (send (send d :layout) :dim)))
          (ret))
     (dotimes (j (car dims))
       (push (subseq (send d :data) (* j (cadr dims)) (* (1+ j) (cadr dims))) ret))
     (reverse ret)))
  (:imucoords
   ()
   "Returns robot's coords based on imu measurement."
   (send robot :copy-worldcoords))
  (:accel-vector
   ()
   "Returns acceleration [m/s2] of the acceleration sensor."
   (let ((acc (send (cdr (assoc :imu robot-state)) :linear_acceleration)))
     (float-vector (send acc :x) (send acc :y) (send acc :z))))
  (:gyro-vector
   ()
   "Returns angular velocity [rad/s] of the gyro sensor."
   (let ((gyro (send (cdr (assoc :imu robot-state)) :angular_velocity)))
     (float-vector (send gyro :x) (send gyro :y) (send gyro :z))))
  (:state
    (&rest args)
    "Obtains sensor and robot command topics using spin-once."
    (case (car args)
      (:imucoords
       (send-super* :state args)
       (send self :imucoords))
      (t
       (send-super* :state args))))
  ;; automatically define methods for ROSBridge services
  (:define-all-ROSBridge-srv-methods
   (&key (debug-view nil) (ros-pkg-name "hrpsys_ros_bridge"))
   (let ((srv-fnames (send self :get-ROSBridge-srv-fnames ros-pkg-name)))
     (dolist (idl (send self :get-ROSBridge-idl-fnames ros-pkg-name))
       (let ((rtc-name (pathname-name idl)))
         (dolist (srv-name (mapcar #'pathname-name (remove-if-not #'(lambda (x) (and (substringp rtc-name x) (not (= (char x 0) (char "." 0))))) srv-fnames)))
           (let ((method-def (send self :get-ROSBridge-method-def-macro rtc-name srv-name ros-pkg-name)))
             (when method-def
               (if debug-view (pprint (macroexpand method-def)))
               (eval method-def)
               )))))))
  (:get-ROSBridge-fnames-from-type
   (type-name &optional (ros-pkg-name "hrpsys_ros_bridge"))
   (let ((path (ros::resolve-ros-path (format nil "package://~A" ros-pkg-name))))
     (remove-if-not #'(lambda (x) (substringp (format nil ".~A" type-name) x)) (directory (format nil "~A/~A" path type-name)))
     ))
  (:get-ROSBridge-idl-fnames (&optional (ros-pkg-name "hrpsys_ros_bridge")) (send self :get-ROSBridge-fnames-from-type "idl" ros-pkg-name))
  (:get-ROSBridge-srv-fnames (&optional (ros-pkg-name "hrpsys_ros_bridge")) (send self :get-ROSBridge-fnames-from-type "srv" ros-pkg-name))
  (:get-ROSBridge-method-def-macro
   (rtc-name srv-name &optional (ros-pkg-name "hrpsys_ros_bridge"))
   (let* ((meth-name (string-left-trim "_" (string-left-trim rtc-name (string-left-trim "_" (string-left-trim "OpenHRP" srv-name)))))
          (srv-request (read-from-string (format nil "~A::~ARequest" ros-pkg-name srv-name)))
          (init-method (find-if #'(lambda (x) (eq (car x) :init)) (send (eval srv-request) :methods)))
          ;;(new-method-name (read-from-string (format nil ":~A" (string-left-trim "_" (string-left-trim rtc-name (string-left-trim "_" (string-left-trim "OpenHRP" srv-name))))))))
          (new-method-name (read-from-string (format nil ":~A" (string-left-trim "_" (string-left-trim "OpenHRP" srv-name))))))
     (if (find-method self new-method-name)
         (progn
           (warn ";; Method conflict in ROSBridge defmethod!! ;; ~A~%" srv-name)
           nil)
       `(defmethod rtm-ros-robot-interface
          (,new-method-name
           ,(cadr init-method)
           (ros::service-call
            ,(format nil "/~AROSBridge/~A" rtc-name meth-name)
            (instance ,(eval srv-request) :init ,@(mapcan #'(lambda (x) (list (caar x) (cadar x))) (cdadr init-method))))
           )
          )
       )))
  (:set-interpolation-mode
   (interpolation-mode)
   "Set interpolation mode for SequencePlayer."
   (if (integerp interpolation-mode)
       interpolation-mode
     (let ((im (read-from-string (format nil "HRPSYS_ROS_BRIDGE::OPENHRP_SEQUENCEPLAYERSERVICE_INTERPOLATIONMODE::*~A*" (string-downcase interpolation-mode)))))
       (if (boundp im)
           (send self :sequenceplayerservice_setinterpolationmode :i_mode_ (eval im))
         (error ";; no such interpolation-mode ~A in :set-interpolation-mode~%" interpolation-mode)))
     ))
  ;;
  ;; Calculate zmp from state [mm]
  ;; example ;; (progn (send *ri* :go-velocity 0 0 0) (objects (list (*ri* . robot))) (do-until-key (let ((zmp (send *ri* :calc-zmp-from-state))) (send *irtviewer* :draw-objects :flush nil) (send zmp :draw-on :flush t :size 300))))
  (:calc-zmp-from-state
   (&key (wrt :world))
   ;; :wrt is :local => calc local zmp for (*ri* . robot)'s root-link coords
   ;; :wrt is :world => calc world zmp for (*ri* . robot)
   (send self :state)
   (send robot :calc-zmp-from-forces-moments
         (mapcar #'(lambda (x) (send self :force-vector x)) '(:rleg :lleg))
         (mapcar #'(lambda (x) (send self :moment-vector x)) '(:rleg :lleg))
         :wrt wrt)
   )
  (:get-robot-date-string
   ()
   (let* ((dt (unix:localtime)))
     (format nil "~A_~A~A~A"
             (send (send self :robot) :name)
             (digits-string (+ 1900 (aref dt 5)) 4)
             (digits-string (1+ (aref dt 4)) 2)
             (digits-string (aref dt 3) 2))))
  )

;; define Euslisp setter and getter method
(defun def-set-get-param-method
  (param-class ;; parameter class
   set-param-method-name get-param-method-name ;; Euslisp setter and getter method which user want to define
   set-param-idl-name get-param-idl-name ;; raw setter and getter method converted from idl2srv files
   &key (optional-args) ;; arguments for raw setter and getter method
        (debug nil))
  (let* ((param-slots-list ;; get slots list for param-class
          (remove-if #'(lambda (x) (string= "plist" x))
                     (mapcar #'(lambda (x) (string-left-trim "::_" (string-left-trim "ros" (format nil "~A" x))))
                             (concatenate cons (send (eval param-class) :slots)))))
         (getter-defmethod-macro
           `(defmethod rtm-ros-robot-interface
              (,get-param-method-name
               ,(if optional-args (list (cadr optional-args)) (list ))
               (send (send self ,get-param-idl-name ,@optional-args) :i_param))))
         ;; generate defmethod like
         ;;  (:set-xx-param (&key yy-zz)
         ;;   (let ((current-param (send self :get-xx-param))
         ;;         (param (instance ww :init (if yy-zz yy-zz (send current-param :yy_zz))))
         ;;      (send self :aaService_setParameter :i_param param)))
         (setter-defmethod-macro
           `(defmethod rtm-ros-robot-interface
              (,set-param-method-name
               ,(append (if optional-args (list (cadr optional-args))) (list '&key) (mapcar #'(lambda (x) (read-from-string (substitute (elt "-" 0) (elt "_" 0) x))) param-slots-list)) ;; replace _ => - for Euslisp friendly argument
               (let* ((current-param ,(append (list 'send 'self get-param-method-name) (if optional-args (list (cadr optional-args)))))
                      (param (instance ,param-class
                                       :init
                                       ,@(apply #'append
                                                (mapcar #'(lambda (x)
                                                            (let ((eus-sym (read-from-string (substitute (elt "-" 0) (elt "_" 0) x)))
                                                                  (param-sym (read-from-string (format nil ":~A" x))))
                                                              (list param-sym (list 'if eus-sym eus-sym (list 'send 'current-param param-sym)))))
                                                        param-slots-list))
                                       )))
                 (send self ,set-param-idl-name :i_param param ,@optional-args)
                 )))))
    (when debug
      (pprint (macroexpand getter-defmethod-macro))
      (pprint (macroexpand setter-defmethod-macro)))
    (eval getter-defmethod-macro)
    (eval setter-defmethod-macro)
    t))

;; SequencePlayerService
(defmethod rtm-ros-robot-interface
  (:set-base-pose
   (&optional base-coords (tm 0.1))
   (warn ";; :set-base-pose is deprecated. Use :set-base-coords~%")
   (unless base-coords
     (setq base-coords (send robot :worldcoords)))
   (send self :sequenceplayerservice_setbasepos :pos (scale 0.001 (send base-coords :pos)) :tm tm)
   (send self :sequenceplayerservice_setbaserpy :rpy (coerce (reverse (car (send base-coords :rpy-angle))) float-vector) :tm tm))
  (:set-base-coords
   (base-coords tm)
   "Set base coordinates in the world frame.
    base-coords is Euslisp coords and tm is [ms]."
   (send self :set-base-pos (send base-coords :worldpos) tm)
   (send self :set-base-rpy (coerce (reverse (car (rpy-angle (send base-coords :worldrot)))) float-vector) tm)
   )
  (:set-base-pos
   (base-pos tm)
   "Set base pos in the world frame.
    base-pos is [mm] and tm is [ms]."
   (send self :sequenceplayerservice_setbasepos :pos (scale 0.001 base-pos) :tm (* 0.001 tm)) ;; [mm]->[m], [ms]->[s]
   )
  (:set-base-rpy
   (base-rpy tm)
   "Set base rpy in the world frame.
    base-rpy is [rad] and tm is [ms]."
   (send self :sequenceplayerservice_setbaserpy :rpy base-rpy :tm (* 0.001 tm)) ;; [ms]->[s]
   )
  (:wait-interpolation-of-group
   (groupname)
   (send self :sequenceplayerservice_waitinterpolationofgroup :gname groupname))
  (:add-joint-group
   (groupname jnames)
   (send self :sequenceplayerservice_addjointgroup :gname groupname :jnames jnames))
  (:remove-joint-group
   (groupname)
   (send self :sequenceplayerservice_removejointgroup :gname groupname))
  (:set-joint-angles-of-group
   (groupname av tm)
   (send self :sequenceplayerservice_setjointanglesofgroup :gname groupname :jvs av :tm tm))
  (:load-pattern (basename &optional (tm 0.0)) (send self :sequenceplayerservice_loadpattern :basename basename :tm tm))
  (:wait-interpolation-seq () (send self :sequenceplayerservice_waitinterpolation))
#| ;; angle group sample
  (send *ri* :add-joint-group "larm" (send-all (send *robot* :larm :joint-list) :name))
  (send *ri* :set-jointangles-of-group "larm" (scale (/ pi 180.0) (send *robot* :larm :angle-vector)) 4.0)
  (send *ri* :waitinterpolation-of-group "larm")
|#
  (:set-ref-forces-moments
   (force-list moment-list tm)
   "Set reference wrenches. wrench-list is list of wrench ([N],[Nm]) for all end-effectors. tm is interpolation time [ms]."
   (send self :sequenceplayerservice_setwrenches :wrenches (apply #'concatenate float-vector (mapcan #'(lambda (f m) (list f m)) force-list moment-list)) :tm (* 1e-3 tm)) ;; [ms]->[s]
   )
  (:set-ref-forces
   (force-list tm &key (update-robot-state t))
   "Set reference forces. force-list is list of force ([N]) for all end-effectors. tm is interpolation time [ms]."
   (if update-robot-state (send self :state))
   (send self :set-ref-forces-moments force-list (send self :reference-moment-vector) tm)
   )
  (:set-ref-moments
   (moment-list tm &key (update-robot-state t))
   "Set reference moments. moment-list is list of moment ([Nm]) for all end-effectors. tm is interpolation time [ms]."
   (if update-robot-state (send self :state))
   (send self :set-ref-forces-moments (send self :reference-force-vector) moment-list tm)
   )
  (:set-ref-force
   (force tm &optional (limb :arms) &key (update-robot-state t))
   "Set reference force [N]. tm is interpolation time [ms].
    limb should be limb symbol name such as :rarm, :larm, :rleg, :lleg, :arms, or :legs."
   (if update-robot-state (send self :state))
   (let ((limbs (case limb
                      (:arms (list :rarm :larm))
                      (:legs (list :rleg :lleg))
                      (t (list limb)))))
     (send self :set-ref-forces
           (mapcar #'(lambda (fs rfv)
                       (if (find-if #'(lambda (l) (equal fs (car (send robot l :force-sensors)))) limbs)
                           force rfv))
                   (send robot :force-sensors) (send self :reference-force-vector))
           tm)
     ))
  (:set-ref-moment
   (moment tm &optional (limb :arms) &key (update-robot-state t))
   "Set reference moment [Nm]. tm is interpolation time [ms].
    limb should be limb symbol name such as :rarm, :larm, :rleg, :lleg, :arms, or :legs."
   (if update-robot-state (send self :state))
   (let ((limbs (case limb
                      (:arms (list :rarm :larm))
                      (:legs (list :rleg :lleg))
                      (t (list limb)))))
     (send self :set-ref-moments
           (mapcar #'(lambda (fs rfv)
                       (if (find-if #'(lambda (l) (equal fs (car (send robot l :force-sensors)))) limbs)
                           moment rfv))
                   (send robot :force-sensors) (send self :reference-moment-vector))
           tm)
     ))
  )

;; CollisionDetectorService
(defmethod rtm-ros-robot-interface
  (:set-tolerance
   (&key (tolerance 0.1) (link-pair-name "all"))
   (send self :collisiondetectorservice_settolerance
         :link_pair_name link-pair-name :tolerance tolerance))
  (:start-collision-detection
   ()
   (send self :collisiondetectorservice_enablecollisiondetection))
  (:stop-collision-detection
   ()
   (send self :collisiondetectorservice_disablecollisiondetection))
  (:get-collision-status
   ()
   (send (send self :collisiondetectorservice_getcollisionstatus) :cs)
   )
  )

;; DataLoggerService
(defmethod rtm-ros-robot-interface
  (:save-log
   (fname &key (set-robot-date-string t))
   "Save log files as [fname].[component_name]_[dataport_name].
    This method corresponds to DataLogger save().
    If set-robot-date-string is t, filename includes date string and robot name. By default, set-robot-date-string is t."
   (send self :dataloggerservice_save :basename (format nil "~A~A" fname (if set-robot-date-string (format nil "_~A" (send self :get-robot-date-string)) ""))))
  ;; start log by clearing log
  (:start-log
   ()
   "Start logging.
    This method corresponds to DataLogger clear()."
   (send self :dataloggerservice_clear))
  (:set-log-maxlength
   (&optional (maxlength 4000))
   "Set max log length.
    This method corresponds to DataLogger maxLength()."
   (send self :dataloggerservice_maxlength :len maxlength))
  )

;; RobotHardwareService
(defmethod rtm-ros-robot-interface
  (:set-servo-gain-percentage
   (name percentage)
   (send self :robothardwareservice_setservogainpercentage :name name :percentage percentage))
  (:remove-force-sensor-offset () (send self :robothardwareservice_removeforcesensoroffset))
  (:set-servo-error-limit
    (name limit)
    (send self :robothardwareservice_setservoerrorlimit :name name :limit limit)
    )
  (:calibrate-inertia-sensor
   ()
   (send self :robothardwareservice_calibrateInertiaSensor)
   )
  )

(def-set-get-param-method 'hrpsys_ros_bridge::OpenHRP_ImpedanceControllerService_impedanceParam
  :raw-set-impedance-controller-param :raw-get-impedance-controller-param
  :impedancecontrollerservice_setimpedancecontrollerparam :impedancecontrollerservice_getimpedancecontrollerparam
  :optional-args (list :name 'name))

;; ImpedanceControllerService
(defmethod rtm-ros-robot-interface
  (:start-impedance
   (limb &rest args)
   "Start impedance controller mode.
    limb should be limb symbol name such as :rarm, :larm, :rleg, :lleg, :arms, or :legs."
   (if args
       (progn
         (send* self :set-impedance-controller-param limb args)
         (send self :raw-start-impedance limb))
     (send self :raw-start-impedance limb)))
  (:raw-start-impedance
   (limb)
   (send self :force-sensor-method
         limb
         #'(lambda (name &rest _args)
             (send self :impedancecontrollerservice_startimpedancecontroller :name (string-downcase name)))
         :raw-start-impedance))
  (:stop-impedance
   (limb)
   "Stop impedance controller mode.
    limb should be limb symbol name such as :rarm, :larm, :rleg, :lleg, :arms, or :legs."
   (send self :force-sensor-method
         limb
         #'(lambda (name &rest _args)
             (send self :impedancecontrollerservice_stopimpedancecontroller :name (string-downcase name)))
         :stop-impedance))
  (:set-impedance-controller-param
   (limb &rest args)
   "Set impedance controller parameter like (send *ri* :set-impedance-controller-param :rarm :K-p 400).
    limb should be limb symbol name such as :rarm, :larm, :rleg, :lleg, :arms, or :legs."
   (send* self :force-sensor-method
          limb
          #'(lambda (name &rest _args)
              (send* self :raw-set-impedance-controller-param (string-downcase name) args))
          :set-impedance-controller-param
          args))
  (:get-impedance-controller-param
   (limb)
   "Get impedance controller parameter.
    limb should be limb symbol name such as :rarm, :larm, :rleg, :lleg, :arms, or :legs."
   (send self :force-sensor-method
         limb
         #'(lambda (name &rest _args)
             (send self :raw-get-impedance-controller-param (string-downcase name)))
         :get-impedance-controller-param))
  (:force-sensor-method
   (limb method-func method-name &rest args)
   (cond
    ((eq limb :legs) (mapcar #'(lambda (l) (send* self method-name l args)) '(:rleg :lleg)))
    ((eq limb :arms) (mapcar #'(lambda (l) (send* self method-name l args)) '(:rarm :larm)))
    ((and (find-method robot limb) (car (send robot limb :force-sensors)))
     (apply method-func limb args))
    (t (error ";; No such limb or force sensor is defined for ~A~%." limb))
    ))
  )

;; RemoveForceSensorLinkOffset
(def-set-get-param-method 'hrpsys_ros_bridge::OpenHRP_RemoveForceSensorLinkOffsetService_ForceMomentOffsetParam
  :raw-set-forcemoment-offset-param :raw-get-forcemoment-offset-param
  :removeforcesensorlinkoffsetservice_setforcemomentoffsetparam :removeforcesensorlinkoffsetservice_getforcemomentoffsetparam
  :optional-args (list :name 'name))

(defmethod rtm-ros-robot-interface
  (:set-forcemoment-offset-param
   (limb &rest args)
   (send* self :force-sensor-method
         limb
         #'(lambda (name base-name target-name &rest _args)
             (send* self :raw-set-forcemoment-offset-param name _args))
         :set-forcemoment-offset-param
         args))
  (:get-forcemoment-offset-param
   (limb)
   (send self :force-sensor-method
         limb
         #'(lambda (name base-name target-name &rest _args)
             (send self :raw-get-forcemoment-offset-param name))
         :get-forcemoment-offset-param))
  (:load-forcemoment-offset-param
   (fname &key (set-offset t))
   (mapcar #'(lambda (x)
               (send* self :set-forcemoment-offset-param (car x)
                      (if set-offset
                          (cdr x)
                        (list :link-offset-mass (cadr (memq :link-offset-mass (cdr x)))
                              :link-offset-centroid (cadr (memq :link-offset-centroid (cdr x)))))))
           (with-open-file
            (f fname :direction :input)
            (read f nil nil)))
   )
  (:load-forcemoment-offset-params
   (filename)
   "Load RMFO offset parameters from parameter file.
    This method corresponds to RemoveForceSensorLinkOffset loadForceMomentOffsetParams()."
   (send self :removeforcesensorlinkoffsetservice_loadforcemomentoffsetparams :filename filename)
   )
  (:dump-forcemoment-offset-params
   (filename &key (set-robot-date-string t))
   "Save all RMFO offset parameters.
    This method corresponds to RemoveForceSensorLinkOffset dumpForceMomentOffsetParams().
    If set-robot-date-string is t, filename includes date string and robot name. By default, set-robot-date-string is t."
   (send self :removeforcesensorlinkoffsetservice_dumpforcemomentoffsetparams :filename (format nil "~A~A" filename (if set-robot-date-string (format nil "_~A" (send self :get-robot-date-string)) "")))
   )
  (:reset-force-moment-offset-arms
   ()
   "Remove force and moment offset for :rarm and :larm"
   (send self :reset-force-moment-offset '(:rarm :larm)))
  (:reset-force-moment-offset
   (limbs)
   "Remove force and moment offsets. limbs should be list of limb symbol name."
   (send self :_reset-force-moment-offset limbs :force)
   (send self :_reset-force-moment-offset limbs :moment)
   )
  (:_reset-force-moment-offset
   (limbs f/m &key (itr 10))
   (let* ((params (mapcar #'(lambda (alimb) (send self :get-forcemoment-offset-param alimb)) limbs))
          (nominal-mgs (mapcar #'(lambda (param) (scale (* 1e-3 (send param :link_offset_mass)) *g-vec*)) params)))
     (labels ((calc-off
               (alimb param nominal-mg)
               (v+ (send self (if (eq f/m :force) :force-vector :moment-vector) alimb)
                   (if (eq f/m :force)
                       (send (car (send robot alimb :force-sensors)) :inverse-rotate-vector nominal-mg)
                     (v* (send param :link_offset_centroid) (send (car (send robot alimb :force-sensors)) :inverse-rotate-vector nominal-mg)))))
              (get-avg-fm
               ()
               (let ((fm (mapcar #'(lambda (i)
                                     (send self :state)
                                     (mapcar #'(lambda (alimb) (send self (if (eq f/m :force) :off-force-vector :off-moment-vector) alimb)) limbs))
                                 (make-list itr))))
                 (mapcar #'(lambda (alimb)
                             (let ((idx (position alimb limbs)))
                               (vector-mean (mapcar #'(lambda (d) (elt d idx)) fm))))
                         limbs))))
       ;; estimate offsets
       (let* ((tmp-fm-offsets (mapcar #'(lambda (i)
                                          (send self :state)
                                          (mapcar #'calc-off limbs params nominal-mgs))
                                      (make-list itr)))
              (new-fm-offsets (mapcar #'(lambda (alimb)
                                          (let ((idx (position alimb limbs)))
                                            (vector-mean (mapcar #'(lambda (d) (elt d idx)) tmp-fm-offsets))))
                                      limbs))
              (org-fm-list (get-avg-fm)))
         ;; set offsets
         (mapcar #'(lambda (alimb new-fm-offset)
                     (send self :set-forcemoment-offset-param alimb
                           (if (eq f/m :force) :force-offset :moment-offset)
                           new-fm-offset))
                 limbs new-fm-offsets)
         (unix:usleep 10000)
         ;; check ;; compare sensor value before & after resetting
         (mapcar #'(lambda (alimb org-fm new-fm)
                     (format t ";; ~A error of ~A ;; ~A[~A] -> ~A[~A]~%"
                             (string-downcase f/m) alimb
                             (norm org-fm) (if (eq f/m :force) "N" "Nm")
                             (norm new-fm) (if (eq f/m :force) "N" "Nm")))
                 limbs org-fm-list (get-avg-fm))
         ))))
  )

;; AutoBalancerService
(def-set-get-param-method
  'hrpsys_ros_bridge::Openhrp_AutoBalancerService_GaitGeneratorParam
  :raw-set-gait-generator-param :get-gait-generator-param
  :autobalancerservice_setgaitgeneratorparam :autobalancerservice_getgaitgeneratorparam)

(defmethod rtm-ros-robot-interface
  (:start-auto-balancer
   (&key (limbs '(:rleg :lleg)))
   (send self :autobalancerservice_startAutoBalancer
         :limbs (mapcar #'(lambda (x) (format nil "~A" (string-downcase x))) limbs)))
  (:stop-auto-balancer () (send self :autobalancerservice_stopAutoBalancer))
  (:go-pos-no-wait
   (xx yy th)
   (send self :autobalancerservice_goPos :x xx :y yy :th th))
  (:go-pos
   (xx yy th)
   (send self :go-pos-no-wait xx yy th)
   (send self :wait-foot-steps))
  (:get-foot-step-param
   ()
   (send (send self :autobalancerservice_getfootstepparam) :i_param)
   )
  (:set-foot-steps-no-wait
   (fs)
   (send self :autobalancerservice_setfootsteps
         :fs
         (mapcar #'(lambda (f)
                     (send self :eus-footstep->abc-footstep f))
                 fs)))
  (:set-foot-steps
   (fs)
   (send self :set-foot-steps-no-wait fs)
   (send self :wait-foot-steps))
  (:go-velocity
   (vx vy vth)
   (send self :autobalancerservice_goVelocity :vx vx :vy vy :vth vth))
  (:go-stop
   ()
   (send self :autobalancerservice_goStop))
  (:calc-go-velocity-param-from-velocity-center-offset
   (ang velocity-center-offset)
   "Calculate go-velocity velocities from rotation center and rotation angle.
    ang is rotation angle [rad]. velocity-center-offset is velocity center offset [mm] from foot mid coords."
   (let* ((default-step-time (send (send self :get-gait-generator-param) :default_step_time)) ;; [s]
          (cen (make-cascoords :pos velocity-center-offset))
          (cc (make-cascoords)))
     (send cen :assoc cc)
     (send cen :rotate (deg2rad ang) :z)
     (let ((tf (send (make-coords) :transformation cc)))
       (list
        (/ (* 1e-3 (elt (send tf :worldpos) 0)) default-step-time) ;; velx [m/s]
        (/ (* 1e-3 (elt (send tf :worldpos) 1)) default-step-time) ;; vely [m/s]
        (/ ang default-step-time) ;; velth [rad/s]
        ))))
  (:wait-foot-steps
   ()
   (send self :autobalancerservice_waitFootSteps))
  ;; wrap :set-gait-generator-param to use symbol for default-orbit-type
  (:set-gait-generator-param
   (&rest args &key default-orbit-type &allow-other-keys)
   (send* self :raw-set-gait-generator-param
          :default-orbit-type
          (if (or (null default-orbit-type) (integerp default-orbit-type))
              default-orbit-type
            (let ((ot (read-from-string (format nil "HRPSYS_ROS_BRIDGE::OPENHRP_AUTOBALANCERSERVICE_ORBITTYPE::*~A*" (string-downcase default-orbit-type)))))
              (if (boundp ot)
                  (eval ot)
                (error ";; no such :default-orbit-type ~A in :set-gait-generator-param~%" default-orbit-type))
              ))
          args))
  (:print-gait-generator-orbit-type
   ()
   (let ((cs (constants "" "HRPSYS_ROS_BRIDGE::OPENHRP_AUTOBALANCERSERVICE_ORBITTYPE")))
     (mapcar #'(lambda (x) (format t ";; ~A => ~A~%" x (eval x))) cs)
     t))
  ;; :get-auto-balancer-param and :set-auto-balancer-param is not defined by def-set-get-param-method yet.
  (:get-auto-balancer-param
   ()
   (send (send self :autobalancerservice_getautobalancerparam) :i_param))
  (:set-auto-balancer-param
   (&key default-zmp-offsets move-base-gain)
   (let* ((current-param (send self :get-auto-balancer-param))
          (param (instance hrpsys_ros_bridge::Openhrp_AutoBalancerService_AutoBalancerParam
                           :init
                           :default_zmp_offsets
                           (if default-zmp-offsets
                               (let ((dzo (copy-object (send current-param :default_zmp_offsets))))
                                 (setq (dzo . ros::_data)
                                       (apply #'concatenate float-vector (mapcar #'(lambda (x) (scale 1e-3 x))
                                                                                 default-zmp-offsets)))
                                 dzo)
                             (send current-param :default_zmp_offsets))
                           :move_base_gain (if move-base-gain move-base-gain (send current-param :move_base_gain)))))
     (send self :autobalancerservice_setautobalancerparam :i_param param)))
  (:abc-footstep->eus-footstep
   (f)
   (make-coords :pos (scale 1e3 (send f :pos))
                :rot (quaternion2matrix (send f :rot)))
   )
  (:eus-footstep->abc-footstep
   (f)
   (instance hrpsys_ros_bridge::openhrp_autobalancerservice_footstep :init
             :pos (scale 1e-3 (send f :worldpos))
             :rot (matrix2quaternion (send f :worldrot))
             :leg (string-downcase (if (find-method f :l/r) (send f :l/r) (send f :name))))
   )
  (:cmd-vel-cb
   (msg &key (vel-x-ratio 1.0) (vel-y-ratio 1.0) (vel-th-ratio 1.0))
   (send self :go-velocity
	 (* vel-x-ratio (send (send msg :linear) :x))
         (* vel-y-ratio (send (send msg :linear) :y))
         (* vel-th-ratio (send (send msg :angular) :z)))
   )
  (:cmd-vel-mode
   ()
   (send self :start-cmd-vel-mode)
   (do-until-key
    (send self :go-velocity 0 0 0)
    (ros::spin-once)
    (ros::sleep)
    )
   (send self :stop-cmd-vel-mode)
   )
  (:start-cmd-vel-mode
   ()
   (print ";; start cmd-vel mode")
   (ros::subscribe "cmd_vel" geometry_msgs::Twist #'send self :cmd-vel-cb)
   (send self :go-velocity 0 0 0)
   (print ";; start cmd-vel mode done.")
   )
  (:stop-cmd-vel-mode
   ()
   (print ";; stop cmd-vel mode")
   (send self :go-stop)
   (ros::unsubscribe "cmd_vel")
   (print ";; stop cmd-vel mode done.")
   )
  )

;; SoftErrorLimiterService
(defmethod rtm-ros-robot-interface
  (:set-soft-error-limit
    (name limit)
    (send self :softerrorlimiterservice_setservoerrorlimit :name name :limit limit)
    )
  )

;; StabilizerService
(def-set-get-param-method
  'hrpsys_ros_bridge::Openhrp_StabilizerService_stParam
  :raw-set-st-param :get-st-param
  :stabilizerservice_setparameter :stabilizerservice_getparameter)

(defmethod rtm-ros-robot-interface
  (:set-st-param
   (&rest args &key st-algorithm &allow-other-keys)
   (send* self :raw-set-st-param
          :st-algorithm
          (if (or (null st-algorithm) (integerp st-algorithm))
              st-algorithm
            (let ((sa (read-from-string (format nil "HRPSYS_ROS_BRIDGE::OPENHRP_STABILIZERSERVICE_STALGORITHM::*~A*" (string-downcase st-algorithm)))))
              (if (boundp sa)
                  (eval sa)
                (error ";; no such :st-algorithm ~A in :set-st-param~%" st-algorithm))))
          args))
  (:start-st
   ()
   (send self :stabilizerservice_startstabilizer)
   )
  (:stop-st
   ()
   (send self :stabilizerservice_stopstabilizer)
   )
  )

;; KalmanFilterService
(def-set-get-param-method
  'hrpsys_ros_bridge::Openhrp_KalmanFilterService_KalmanFilterParam
  :set-kalman-filter-param :get-kalman-filter-param
  :kalmanfilterservice_setkalmanfilterparam :kalmanfilterservice_getkalmanfilterparam)

(defun print-end-effector-parameter-conf-from-robot
  (rb)
  (format t "end_effectors:")
  (dolist (l '(:rarm :larm :rleg :lleg))
    (let ((rl (send (send (send rb l :root-link) :parent) :joint)))
      (format t " ~A,~A,~A," (string-downcase (string l)) (send (send (send rb l :end-coords :parent) :joint) :name) (if rl (send rl :name) "WAIST"))
      (let* ((dif (send (send rb l :end-coords :parent) :transformation (send rb l :end-coords)))
             (wp (scale 1e-3 (send dif :worldpos))) ;; [mm] -> [m]
             (wr (normalize-vector (matrix-log (send dif :worldrot))))
             (wrn (norm (matrix-log (send dif :worldrot)))))
         (format t "~A,~A,~A," (elt wp 0) (elt wp 1) (elt wp 2))
         (format t "~A,~A,~A,~A," (elt wr 0) (elt wr 1) (elt wr 2) wrn)
         )))
  (format t "~%")
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utility functions for seq
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun dump-seq-pattern-file
  (rs-list output-basename &key (initial-sync-time 3.0)) ;; [s]
  "Dump pattern file for SequencePlayer.
     rs-list : list of (list :time time0 :angle-vector av :root-coords rc ...).
               Fields other than :time and :angle-vector are optional.
     output-basename : output file (output-basename.pos, ...).
     root-coords : worldcoords for root link.
     zmp : world zmp[mm].
     wrench-list : world (list force-list moment-list) at end effector."
  (with-open-file
   (pf (format nil "~A.pos" output-basename) :direction :output) ;; pos file -> joint angles
   (dolist (l rs-list)
     ;; write pos file
     (format pf "~A " (+ initial-sync-time (cadr (memq :time l))))
     (let ((av (cadr (memq :angle-vector l))))
       (dotimes (i (length av))
         (format pf "~A " (deg2rad (elt av i)))
         ))
     (format pf "~%"))) ;; with-open-file for .pos file
  (when (cadr (memq :torque-vector (car rs-list)))
    (with-open-file
     (tf (format nil "~A.torque" output-basename) :direction :output) ;; torque file -> joint torques
     (dolist (l rs-list)
       ;; write torque file
       (format tf "~A " (+ initial-sync-time (cadr (memq :time l))))
       (let ((av (cadr (memq :torque-vector l))))
         (dotimes (i (length av))
           (format tf "~A " (elt av i))
           ))
       (format tf "~%")))) ;; with-open-file for .torque file
  (when (cadr (memq :root-coords (car rs-list)))
    (with-open-file
     (wf (format nil "~A.waist" output-basename) :direction :output) ;; waist file -> base position and orientation
     (dolist (l rs-list)
       ;; write waist file
       (format wf "~A " (+ initial-sync-time (cadr (memq :time l))))
       (let ((wp (scale 1e-3 (send (cadr (memq :root-coords l)) :worldpos))) ;; [mm] -> [m]
             (wr (car (send (send (cadr (memq :root-coords l)) :copy-worldcoords) :rpy-angle))))
         (format wf "~A ~A ~A " (elt wp 0) (elt wp 1) (elt wp 2))
         (format wf "~A ~A ~A " (elt wr 2) (elt wr 1) (elt wr 0))
         (format wf "~%")
         ))) ;; with-open-file for .waist file
    )
  (when (or (cadr (memq :root-local-zmp (car rs-list)))
            (and (cadr (memq :root-coords (car rs-list))) (cadr (memq :zmp (car rs-list)))))
    (with-open-file
     (zf (format nil "~A.zmp" output-basename) :direction :output) ;; zmp file -> root-relative zmp[m]
     (dolist (l rs-list)
       ;; write zmp file
       (format zf "~A " (+ initial-sync-time (cadr (memq :time l))))
       (let ((zp (scale 1e-3
                        (or (cadr (memq :root-local-zmp l))
                            (send (cadr (memq :root-coords l)) :inverse-transform-vector (cadr (memq :zmp l))))
                        ))) ;; [mm] -> [m]
         (format zf "~A ~A ~A " (elt zp 0) (elt zp 1) (elt zp 2))
         (format zf "~%")
         ))) ;; with-open-file for .zmp file
    )
  (when (or (cadr (memq :ee-local-wrench-list (car rs-list)))
            (and (cadr (memq :end-coords-list (car rs-list))) (cadr (memq :wrench-list (car rs-list)))))
    (with-open-file
     (wrf (format nil "~A.wrenches" output-basename) :direction :output) ;; wrench file -> force and moment ;; 6 x force-sensor-num
     (dolist (l rs-list)
       ;; write wrenches file
       (format wrf "~A " (+ initial-sync-time (cadr (memq :time l))))
       (let ((wrl
              (or (cadr (memq :ee-local-wrench-list l))
                  (list
                   (mapcar #'(lambda (ee ff)
                               (send ee :inverse-rotate-vector ff))
                           (cadr (memq :end-coords-list l)) (car (cadr (memq :wrench-list l))))
                   (mapcar #'(lambda (ee mm)
                               (send ee :inverse-rotate-vector mm))
                           (cadr (memq :end-coords-list l)) (cadr (cadr (memq :wrench-list l))))))))
         (dotimes (j (length (car wrl))) ;; j is limb index
           (let ((f (elt (car wrl) j)) (m (elt (cadr wrl) j)))
             (dotimes (i 3) (format wrf "~A " (elt f i))) ;; force
             (dotimes (i 3) (format wrf "~A " (elt m i))) ;; moment
             )))
       (format wrf "~%")
       )) ;; with-open-file for .wrenches file
    )
  (when (cadr (memq :optional-data (car rs-list)))
    (with-open-file
     (opf (format nil "~A.optionaldata" output-basename) :direction :output) ;; optionaldata file
     (let ((len (length (cadr (memq :optional-data (car rs-list))))))
       (dolist (rs rs-list)
         (let ((dd (cadr (memq :optional-data rs))))
           (format opf "~A " (+ initial-sync-time (cadr (memq :time rs))))
           (dotimes (i len) (format opf "~A " (elt dd i))))
         (format opf "~%")
         )
       )) ;; with-open-file for .optionaldata
    )
  )

(defun load-from-seq-pattern-file (input-basename)
  "Load from seq pattern file and generate robot state list."
  (labels ((data-string-split ;; this function will be replaced by https://github.com/euslisp/EusLisp/issues/16
            (str separator)
            (let ((start-idx 0) (ret))
              (dotimes (i (length str))
                (when (= (elt str i) (elt separator 0))
                  (push (subseq str start-idx i) ret)
                  (setq start-idx (1+ i))))
              (if (/= start-idx (length str)) (push (subseq str start-idx) ret))
              (reverse ret)))
           (data-str->data-list
            (data-str)
            (mapcar #'(lambda (x) (read-from-string x))
                    (remove-if #'(lambda (x) (string= "" x)) (data-string-split data-str " ")))))
    (let (rs-list)
      ;; pos file
      (let ((pln) (posfile (concatenate string input-basename ".pos")))
        (with-open-file
         (pf posfile :direction :input)
         (while (setq pln (read-line pf nil))
           (let ((dd (data-str->data-list pln)))
             (push (list :angle-vector (map float-vector #'rad2deg (concatenate float-vector (cdr dd)))
                         :time (car dd))
                   rs-list)
             ))))
      (setq rs-list (reverse rs-list))
      ;; waist file
      (let ((wln) (waistfile (concatenate string input-basename ".waist")) (idx 0))
        (if (probe-file waistfile)
            (with-open-file
             (wf waistfile :direction :input)
             (while (setq wln (read-line wf nil))
               (let ((dd (data-str->data-list wln)))
                 (nconc (elt rs-list idx)
                        (list :root-coords (make-coords :pos (float-vector (* 1e3 (elt dd 1)) (* 1e3 (elt dd 2)) (* 1e3 (elt dd 3))) ;; [m]->[mm]
                                                        :rpy (list (elt dd 6) (elt dd 5) (elt dd 4))))) ;; rpy->ypr
                 (incf idx)
                 )))))
      ;; zmp file
      (let ((zln) (zmpfile (concatenate string input-basename ".zmp")) (idx 0))
        (if (probe-file zmpfile)
            (with-open-file
             (zf zmpfile :direction :input)
             (while (setq zln (read-line zf nil))
               (let* ((dd (data-str->data-list zln))
                      (root-local-zmp (float-vector (* 1e3 (elt dd 1)) (* 1e3 (elt dd 2)) (* 1e3 (elt dd 3))))) ;; [m]->[mm]
                 (nconc (elt rs-list idx)
                        (if (cadr (memq :root-coords (elt rs-list idx)))
                            (list :zmp (send (cadr (memq :root-coords (elt rs-list idx))) :transform-vector root-local-zmp))
                          (list :root-local-zmp root-local-zmp)))
                 (incf idx)
                 )))))
      rs-list)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utility functions for project generator generation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; clone euslisp robot and objects to OpenHRP3 project file
;;   add euslisp model + locate euslisp model in OpenHRP3 world
(defun dump-project-file-by-cloning-euslisp-models
  (robot robot-file-path ;; robot euslisp model, robot VRML(or Collada) file path
   &key (object-models) (object-models-file-path) ;; list of object euslisp model, list of object VRML(or Collada) file path
        (nosim) (timestep 0.005) (dt 0.005) ;; [s]
        (output-fname (format nil "/tmp/~A" (send robot :name)))) ;; output file name "output-fname.xml"
  ;; TODO : Is longfloor.wrl necessary??
  (let ((str
         (format nil "rosrun hrpsys_ros_bridge rtmtest -t hrpsys_tools _gen_project.launch \\\
               INPUT:=~A,~A \\\
               OBJECT_MODELS:='`rospack find openhrp3`/share/OpenHRP-3.1/sample/model/longfloor.wrl,0,0,0,1,0,0,0 ~A' \\\
               OUTPUT:=~A.xml \\\
               INTEGRATE:=~A CORBA_PORT:=15005 CONF_DT_OPTION:='--dt ~A' \\\
               SIMULATION_TIMESTEP_OPTION:='--timeStep ~A' \\\
               SIMULATION_JOINT_PROPERTIES_OPTION:='--joint-properties ~A'"
                 robot-file-path
                 (gen-ProjectGenerator-model-root-coords-string robot)
                 (let ((obj-path-list
                        (mapcar #'(lambda (fpath obj) (format nil "~A,~A" fpath (gen-ProjectGenerator-model-root-coords-string obj)))
                                object-models-file-path object-models)))
                   (if obj-path-list
                       (reduce #'(lambda (x y) (format nil "~A ~A" x y)) obj-path-list)
                     ""))
                 (format nil "~A~A" output-fname (if nosim "_nosim" ""))
                 (if nosim "false" "true")
                 dt
                 timestep
                 (gen-ProjectGenerator-joint-properties-string robot)
                 )))
    (unix:system (format nil "bash -c -i \"~A;exit 0\";exit 0" str))
    ))

(defun gen-ProjectGenerator-joint-properties-string
  (robot)
  (let ((str))
    (dolist (j (send robot :joint-list))
      (if str
          (setq str (format nil "~A,~A.angle,~A" str (send j :name) (deg2rad (send j :joint-angle))))
        (setq str (format nil "~A.angle,~A" (send j :name) (deg2rad (send j :joint-angle)))))
      )
    str))

(defun gen-ProjectGenerator-model-root-coords-string
  (obj)
  (let* ((dr (matrix-log (send (car (send obj :links)) :worldrot)))
         (ndr (normalize-vector dr))
         (rpos (scale 1e-3 (send (car (send obj :links)) :worldpos))))
      (format nil "~A,~A,~A,~A,~A,~A,~A"
              (elt rpos 0) (elt rpos 1) (elt rpos 2)
              (elt ndr 0) (elt ndr 1) (elt ndr 2) (/ (elt dr 1) (elt ndr 1)) ;; openhrp3 axis angle orientation representation
              )))

